
import numpy as np
import cv2
import json
import matplotlib.pyplot as plt
from serial import Serial

import time

from tqdm import tqdm

sx, sy = 1, 1 # the sign of last operation, when sign change, apply an extra movement compensation
compensate_x, compensate_y = 100, 150 # the compensation values, should be modified according to the 3D parts

help_text = '''
Use ser.write(b'200 300') to move the cursor to the origin (bot left) corner
Call `write_steps()` to draw the image on etch-a-sketch.
Call `draw_steps()` to preview the drawing process
''' 

DEBUG = False
#DEBUG = True

fn_step = r'kun.bmp.json' # generated by the route_planner
with open(fn_step, 'r') as f:
    steps = json.load(f)
print(len(steps))
steps = steps[:5000*2]

steps = np.array(steps)
print(steps.shape)
steps = steps.reshape(-1, 2)
print(steps.shape)

if not DEBUG:
    ser = Serial(port='COM3', baudrate=9600, timeout = 1) # serial port, usually COM3 on Windows
else:
    ser = []

def wait_rsp(ser):
    ser.timeout = 1
    while(1):
        rsp = ser.readline()
        if b'dXdY' in rsp:
            return
        
def sign(x):
    return 0 if x == 0 else (1 if x > 0 else -1)
        
x, y = 0, 0

def write_steps():
    global x,y,ser,sx,sy,compensate_x,compensate_y
    x, y = 0,0
    im = np.ones((400, 650, 3), np.uint8) * 255
    for nx,ny in tqdm(steps):
        dx, dy = nx-x, ny-y
        sdx, sdy = sign(dx), sign(dy)
        if sdx != 0 and sdx != sx:
            sx = sdx
            dx = sdx * (abs(dx) + compensate_x)
        if sdy != 0 and sdy != sy:
            sy = sdy
            dy = sdy * (abs(dy) + compensate_y)
        
        cv2.line(im, (x//10,(4000-y)//10), (nx//10,(4000-ny)//10), (0,0,0)) 
        x,y = nx, ny
        ser.write(f'{dx} {dy}\n'.encode('utf8'))
        wait_rsp(ser)
        cv2.imshow('w1', im)
        cv2.waitKey(1)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

    
def draw_steps(st=-1):
    global x,y,ser
    x, y = 0,0
    im = np.ones((400, 650, 3), np.uint8) * 255
    sts = 0
    for nx,ny in tqdm(steps[:st]):
        dx, dy = nx-x, ny-y
        cv2.line(im, (x//10,(4000-y)//10), (nx//10,(4000-ny)//10), (0,0,0))        
        x,y = nx, ny
        if sts % 10 == 0:
            cv2.imshow('w1', im)
            cv2.waitKey(1)
            #time.sleep(0.01)
        sts += 1
        
        

if not DEBUG:
    print(help_text)
    import pdb
    pdb.set_trace()